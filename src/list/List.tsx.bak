import {
  defineComponent,
  reactive,
  toRefs,
  computed,
  PropType,
  isVue2
} from 'vue-demi';

import { createNamespace, mconsole, emitModel } from '../utils';


import { List as VanList, Toast, PullRefresh as VanPullRefresh, Loading } from 'vant';

const [name, rem, t] = createNamespace('list');



export type RequestParams = [
  /**
   * page
   */
  page: number
];



export default defineComponent({
  name,
  components: {
    VanList,
    VanPullRefresh
  },
  props: {
    /**
     * list
     */
    list: {
      type: Array,
      default: [],
    },
    /**
     * total
     */
    total: {
      type: Number,
      default: 0,
    },
    /**
     * request async function
     */
    requestFn: {
      type: Function as PropType<(...reqData: RequestParams) => Promise<void>>,
      require: true,
    },
    /**
     * show toast
     */
    showToast: {
      type: Boolean,
      default: true,
    },
    /**
     * config
     */
    config: {
      type: Object,
    },
    loadingText: String,
    errorText: {
      type: String,
    },
    finishedText: {
      type: String,
    },
    pullingText: {
      type: String
    },
    loosingText: {
      type: String
    },
    successText: {
      type: String
    },
    refLoadingText: {
      type: String
    }
  },
  setup(props, { emit, slots }: any) {
    const { total, showToast } = toRefs(props);
    const list = computed<any[]>({
      get() {
        return props.list;
      },
      set() {
        // vm.$emit(`update:${propName}`, value);
        // emitModel(emit, "input", "list", []);
        emit(`update:list`, []);
      },
    });
    const state = reactive({
      isVue2,
      // loading status
      loading: false,
      // finished
      finished: false,
      // is error
      error: false,
      // page number
      page: 0,
      // search object
      search: {
        key: null,
      },
      // refreshing
      refreshing: false,
    });

    // Pull on loading
    const onLoad = async () => {
      if (!props.requestFn) {
        mconsole.error(t('need :RequestFn="RequestFn"'));
        state.finished = true;
        return;
      }
      try {
        state.loading = true;
        // page + 1 
        state.page += 1;
        // Pull up load request function
        await props.requestFn(state.page)

        // refreshing
        if (state.refreshing) {
          state.refreshing = false;
        }
        // Load finished
        state.loading = false;
        // All data is loaded
        if (list.value.length >= total.value) {
          state.finished = true;
        }
      } catch (error: any) {
        mconsole.error(error);
        showToast.value && Toast.fail(error.message);
        state.error = true;
        state.loading = false;
        // Restore last page number
        state.page -= 1;
      }
    };

    // Must be wrapped
    const onLoadData = () => {
      onLoad();
    };

    // onRefresh
    const onRefresh = () => {
      // clear list
      // emit("input", []);

      // emitModel(emit, "input", "list", []);
      emit(`update:list`, []);
      state.finished = false;
      state.error = false;
      // reset page
      state.page = 0;
      // set refreshing true
      state.refreshing = true;
      onLoadData();
    };


    const searchData = () => {
      // clear list
      emitModel(emit, 'input', 'list', []);
      state.finished = false;
      state.error = false;
      // reset page
      state.page = 0;
      // set loading true
      state.loading = true;
      onLoadData();
    };

    const vanListSlots: {
      [key: string]: any
    } = {};
    slots.default && (vanListSlots.default = () => slots.default())
    slots.loading && (vanListSlots.loading = () => slots.loading())
    slots.finished && (vanListSlots.finished = () => slots.finished())
    slots.error && (vanListSlots.error = () => slots.error())

    const vanPullRefreshSlots: {
      [key: string]: any
    } = {
      default: () => isVue2 ?
        <VanList
          v-model={state.loading}
          finished={state.finished}
          error-text={props.errorText || t('errorText')}
          finished-text={props.finishedText || t('finishedText')}
          loading-text={props.loadingText || t('loadingText')}
          error={state.error}
          onLoad={onLoadData}
          offset="300"
          v-slots={vanListSlots}
        >
        </VanList> :
        <VanList
          v-model:loading={state.loading}
          finished={state.finished}
          error={state.error}
          error-text={props.errorText || t('errorText')}
          finished-text={props.finishedText || t('finishedText')}
          loading-text={props.loadingText || t('loadingText')}
          onLoad={onLoadData}
          offset="300"
          v-slots={
            vanListSlots
          }
        >
        </VanList>
    };

    slots.pulling && (vanPullRefreshSlots.pulling = () => slots.pulling())
    slots.loosing && (vanPullRefreshSlots.loosing = () => slots.loosing())
    slots.loading && (vanPullRefreshSlots.loading = () => slots.loading())


    // export var 
    // defineExpose({
    //   searchData
    // });
    return () => (
      <div class="vp-list">
        <VanPullRefresh
          v-model={state.refreshing}
          onRefresh={onRefresh}
          pulling-text={props.pullingText || t('pullingText')}
          loosing-text={props.loosingText || t('loosingText')}
          success-text={props.successText || t('successText')}
          loading-text={props.refLoadingText || t('refLoadingText')}
          v-slots={vanPullRefreshSlots}
        >

        </VanPullRefresh>
      </div >
    )
  }
})


